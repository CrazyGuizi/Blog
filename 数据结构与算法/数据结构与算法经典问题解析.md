## 链表

### 松散链表
每个结点存储多个元素（简称为块），而每个块中所有的结点由循环链表连接在一起。假设在任何时候松散链表中元素的个数不超过n个，假设除了最后一个快外，其他块所含的元素为[根号n]（向上取整），块的个数不会超过[根号n]（向下取整）。

## 线索二叉树
![线索二叉树](.\线索二叉树.png)

## 外部排序
外部排序是对一类可以处理大量数据的排序算法的统称。外部排序算法适用于处理主存不能容纳的大文件。

简单例子：利用100M的内存对900M的数据进行排序。
1. 将100M数据读入内存，并采用常规方法对其排序（比如快速排序）
2. 把排好序后的数据写回磁盘
3. 重复第一步和第二步，直到所有的数据都被有序存储在大小为100M的文件块中。
4. 将每个有序块内的前10M内容读入主存（总共9个），最后10M作为输出缓冲区。
5. 执行9路归并排序并将结果存储在输出缓冲区中，如果输出缓冲区已满则将结果写入最后的排序文件中。

## 散列
散列有4个组成部分：
1. 散列表
2. 散列函数
3. 冲突
4. 冲突解决技术

散列表或者散列映射是一种数据结构，用以存储关键字及其关联的值。散列表利用散列函数将关键字映射到其关联的值。

散列函数用于将关键字转换成索引。

负载因子=散列表中元素的个数/散列表的长度。当散列表面临再次散列或扩大现有现有散列表记录时的决策参数。

冲突解决技术
- 直接链接法：链表数组的应用
	- 分离链接法
- 开放定址法：基于数组实现
	- 线性探测法（线性搜索）
	- 二次探测法（非线性搜索）
	- 双重散列法（使用两个散列函数）

分离链接法：
将散列表和链表结合，当两个或多个记录散列到相同的位置时，这些记录将构成一个单向链表，称为链。

线性探测法：
从发生冲突的原始位置开始按顺序搜索散列表，如果表中位置被占据，则查找下一个位置。线性探测的问题是表项往往在散列表中聚集。

二次探测：
探测间隔的增加与散列值成正比。聚集问题可以使用二次探测方法消除。从发生冲突的初始位置i开始，如果某个位置被占据，则探测i+1²，i+2²，i+3²等位置。探测间隔由另一个散列函数计算生成，双重散列法用一种更好的方式减少了聚集。

## 字符串算法
检查模式P是否是另一个字符串T的子串。
- 蛮力法

假设P长度为n，T长度为m，那么在T中有m-n+1个可选的位置来比较。

- Robin-Karp字符串匹配算法

使用散列技术代替对文本T中每个可能位置进行检查的方法。只有P的散列值和T中m个字符的散列值相等时才检查。

- 基于有限自动机的字符串匹配算法


- KMP
- Boyce-Moore算法
- 后缀树

## 算法设计
根据设计方法对算法进行分类：
1. 贪婪法

贪婪算法将问题分为多个阶段，在每一个阶段选取当前状态的最优决策，不考虑对后续决策的影响。贪婪算法假设通过局部最优解可以得到全局最优解。

2. 分治法

分：将原问题分成多个子问题，这些子问题是与原问题类型相同的规模更小的实例
递归：递归求解子问题
治：合理地组合子问题的解

3. 动态规划（Dynamic Programming，DP）

它与备忘录方法结合。DP与分治法的不同是：分治法的子问题之间不存在依赖关系，而DP的子问题存在重叠。通过备忘录技术，DP可将许多问题的复杂度从指数降低为多项式级。

4. 线性规划

在满足不等式约束的条件下，最大化（或最小化）输入变量的线性函数。

5. 归约

将一个复杂的问题转化和求解为一个一直有渐进最优解的已知问题。该方法的目标是找一个归约算法，是的归约后的算法复杂度不会更高。例如寻找线性表中位数的算法是：首先将线性表排序，然后寻找有序表中的中间值。这两个步骤分别称为**转化**和**求解**。

