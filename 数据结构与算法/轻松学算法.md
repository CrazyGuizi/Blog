## 散列表（哈希表）
**定义：**利用给定的关键字Key通过哈希函数得到一个相应的Value，类似于手机通讯录里面通过开头字母快速定位的方法。不同的Key可能会得到相同的Value，而同一个Key的Value应该并且要求是一样的。

### 哈希函数
1. 直接寻址法
利用线性函数获取值

2. 数字分析法
通过对数字的分析，发现数据中冲突较少的部分，以此构造哈希函数

3. 平方取中法
4. 取随机数法
5. 除留取余法

### 冲突解决
因为不同的关键之通过哈希函数知乎可能得到的是同一个值，这个时候便产生了冲突，如果直接存放在那个位置，就会有可能覆盖前面已经存放在这里的数据，以下是解决冲突的方法。

1. 开放地址法
可以试探下一个地址，如果没有使用那么就可以存放在这个位置上

2. 再哈希法
产生冲突后可以利用关键字的其他部分再进行哈希计算，如此下去找到一个合适的位置

**3. 链地址法**
在冲突的位置构建一个链表进行存放，这个是很多高级语言常用的一种方法。

4. 建立一个公共溢出区
当发生冲突时可以将冲突地址存放在公共溢出区中。

## 排序算法复杂度
| 类别 | 排序方法 | 时间复杂度 </br> 平均	最好	最坏 | 空间复杂度 </br> 辅助性 | 稳定性 |
| - | - | - | - | - |
| 插入排序 | 直接插入 </br> 希尔排序 | O(n²)	O(n)	O(n²) </br> O(n^1.3)	O(n)	O(n²) | O(1) </br> O(1) | 稳定 </br> 不稳定 |
| 选择排序 | 简单排序 </br> 堆排序 | O(n²)	O(n²)	O(n²) </br> O(nlogn)	O(nlogn)	O(nlogn) | O(1) </br> O(1) | 不稳定 </br> 不稳定 |
| 交换排序 | 冒泡插入 </br> 快速排序 | O(n²)	O(n)	O(n²) </br> O(nlogn) O(nlogn) O(nlogn) | O(1) </br> O(nlogn) | 稳定 </br> 不稳定 |

## 排序算法
1. 桶排序
桶的数量和待排序的数的范围一样多，将待排序的那个数放在对应的桶中，最后从小到大遍历整个桶依次，输出数量不为0的桶对应的数

2. 冒泡排序
两两比较，每一轮比较后最大的数会沉到底，换句话说即最小的数慢慢地浮起来。

3. 快速排序
从给出待排序的数中选定一个作为基数，要求所有在它前面的数都比它小，所有后面的数都比他大。

4. 插入排序
每轮往后移动一位，然后将后面的数插入到前面已经排好序的数中合适的位置。

5. 希尔排序
建立在插入排序的基础上，它并不是每次比较一位，而是每次比较间隔多位，最后减到每次比较一位。

6. 选择排序
每轮排序都选择其中最小的数，然后将其放在放在排好序的数之后。

## 分块查找
实现：结合了顺序查找和二分查找。它由一个索引表和若干个分块组成，其中索引表是排好序的，可用二分查找，每一个数规定了所对应的分块的数据范围。分块可以是有序的也可以是无序的，可用顺序查找，它含有若干个数据。

<table boder=0>
<tr>
<td>
<table>
<caption>索引表</caption>
<td>10</td>
<td>20</td>
<td>30</td>
</table>
</td>

<td>
<table>
<caption>分块一</caption>
<tr>
<td>1</td>
<td>3</td>
<td>9</td>
<td>2</td>
</tr>
</table>

<table>
<caption>分块二</caption>
<tr>
<td>16</td>
<td>13</td>
<td>15</td>
</tr>
</table>

<table>
<caption>分块三</caption>
<tr>
<td>21</td>
<td>22</td>
</tr>
</table>
</td>
</tr>
</table>

## 树

### 满二叉树
每一层、每个节点要么有两颗子树，要么都没有

### 完全二叉树
最后一层的所有节点集中在左边。

